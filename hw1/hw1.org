#+TITLE: Homework Assignment # 1
#+AUTHOR: Miguel Gomez U1318856
#+DATE: 2024-02-02 11:07:53
#+LATEX_HEADER: \documentclass[a4paper, 11pt]{exam}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{titling}
#+LATEX_HEADER: \usepackage{url}
#+LATEX_HEADER: \usepackage{amsmath,amsthm,amssymb}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{graphics}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage[dvipsnames]{xcolor}
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{ragged2e}
#+LATEX_HEADER: \usepackage{courier}
#+LATEX_HEADER: \usepackage{textcomp}
#+LATEX_HEADER: \usepackage{circuitikz}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{enumitem}
#+LATEX_HEADER: \usepackage{karnaugh-map}
#+LATEX_HEADER: \usepackage{bytefield}
#+LATEX_HEADER: \usepackage{mathrsfs}
#+LATEX_HEADER: \usepackage{cancel}
#+LATEX_HEADER: \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{environ}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{algpseudocode}
#+LATEX_HEADER: \lstset{breaklines=true, basicstyle=\ttfamily\tiny, frame=single}


* Homework 1
The extended euclidean algorithm is a spin on the usual algo that allows for us to split the number into two intermediate values. one that is equal to the number we are dividing in the algo multiplied by a number, and another that is the divisor multiplied by the quotient. This expression below is the one we end up with:
** expression
#+begin_export latex
\[
\begin{align*}
g &= gcd(a,b)\\
\exists\ s,t\ |\ s\cdot a + t\cdot b &= g
\end{align*}
\]
#+end_export



#+begin_src bash :results scalar
  start=$(date +%s.%N)
  Singular sing/hw1_b.sing | grep -v -e "\*\* loaded\|\*\* library"
  end=$(date +%s.%N)
  echo "Execution Time: $(echo "$end - $start" | bc) seconds"
#+end_src

#+RESULTS:
#+begin_example
                     SINGULAR                                 /  Development
 A Computer Algebra System for Polynomial Computations       /   version 4.2.1
                                                           0<
 by: W. Decker, G.-M. Greuel, G. Pfister, H. Schoenemann     \   May 2021
FB Mathematik der Universitaet, D-67653 Kaiserslautern        \  Debian 1:4.2.1-p3+ds-1
// ** but for functionality you may wish to change to the new
// ** format. Please refer to the manual for further information.
The example computed GCD of 24 and 16 is:
8
// ** redefining r (ring r = integer, (x), lp;) sing/hw1_b.sing:21
The computed myintGCD of 24 is: 8
The computed myEuclid of 24 is: 8
The computed myExtendedEuclid of the numbers is:

GCD(24,16) = 8
s = 1
t = -1
    
The computed GCD of the list of numbers for problem 1-b is:
10
Auf Wiedersehen.
Execution Time: .061765816 seconds
#+end_example


#+begin_export latex
\[
\subsection{output of hw$1_b$ results}
\begin{lstlisting}[language=Singular]
                     SINGULAR                                 /  Development
 A Computer Algebra System for Polynomial Computations       /   version 4.2.1
                                                           0<
 by: W. Decker, G.-M. Greuel, G. Pfister, H. Schoenemann     \   May 2021
FB Mathematik der Universitaet, D-67653 Kaiserslautern        \  Debian 1:4.2.1-p3+ds-1
// ** but for functionality you may wish to change to the new
// ** format. Please refer to the manual for further information.
The example computed GCD of 24 and 16 is:
8
// ** redefining r (ring r = integer, (x), lp;) hw1_b.sing:21
The computed myintGCD of 24 is: 8
The computed myEuclid of 24 is: 8
The computed myExtendedEuclid of the numbers is:

GCD(24,16) = 8
s = 1
t = -1
    
The computed GCD of the list of numbers for problem 1-b is:
10
Auf Wiedersehen.
Execution Time: .028753389 seconds
\end{lstlisting}
\]
#+end_export


#+begin_export latex
\[
\newpage
\subsection{Pseudocode for the Euclidean algo}
\begin{algorithm}
\caption{Euclidean Algorithm}
\begin{algorithmic}[1]
\Procedure{myExtendedEuclid}{$a$, $b$}
    \State $R1 \gets a$
    \State $R2 \gets b$
    \While{$R2 \neq 0$}
        \State $Q \gets (R1/R2)$
        \State $r \gets R1 - Q \times R2$
        \State $R1 \gets R2$
        \State $R2 \gets r$
    \EndWhile
    \State \textbf{return} $r$
\EndProcedure
\end{algorithmic}
\end{algorithm}
\]
#+end_export


#+begin_export latex
\[
\newpage
\subsection{Pseudocode for the Euclidean algo}
\begin{algorithm}
\caption{Extended Euclidean Algorithm}
\begin{algorithmic}[1]
\Procedure{myExtendedEuclid}{$a$, $b$}
    \State $R1 \gets a$
    \State $R2 \gets b$
    \State $S1 \gets 1$
    \State $S2 \gets 0$
    \State $T1 \gets 0$
    \State $T2 \gets 1$
    \While{$R2 > 0$}
        \State $Q \gets \text{floor}(R1/R2)$
        \State $r \gets R1 - Q \times R2$
        \State $R1 \gets R2$
        \State $R2 \gets r$
        \State $s \gets S1 - Q \times S2$
        \State $S1 \gets S2$
        \State $S2 \gets s$
        \State $t \gets T1 - Q \times T2$
        \State $T1 \gets T2$
        \State $T2 \gets t$
    \EndWhile
    \State \textbf{print} "GCD(", $a$, ",", $b$, ") = ", $S1 \times a + T1 \times b$
    \State \textbf{print} "s = ", $S1$
    \State \textbf{print} "t = ", $T1$
    \State $L \gets \text{list}()$
    \State $L \gets \text{list}(S1 \times a + T1 \times b, S1, T1)$
    \State \textbf{return} $L$
\EndProcedure
\end{algorithmic}
\end{algorithm}
\newpage
\]
#+end_export


** Identify whether the integers 38 and 7 have multiplicative inverses in \mathcal{Z}_{180}
Since the number $p$ we are working with is even, we will not have multiplicative inverses for even numbers. Therefore we only need to find the inverse for the one we can, for 7. 

#+begin_export latex
\[
a \in \mathcal{Z}_{180}\ ,\ a^{-1} \in \mathcal{Z}_{180}\ \text{if}\ gcd(a,180) = 1
\]
#+end_export

#+begin_src bash :results scalar
  start=$(date +%s.%N)
  Singular sing/hw1_c.sing | grep -v -e "\*\* loaded\|\*\* library"
  end=$(date +%s.%N)
  echo "Execution Time: $(echo "$end - $start" | bc) seconds"
#+end_src

#+RESULTS:
#+begin_example
                     SINGULAR                                 /  Development
 A Computer Algebra System for Polynomial Computations       /   version 4.2.1
                                                           0<
 by: W. Decker, G.-M. Greuel, G. Pfister, H. Schoenemann     \   May 2021
FB Mathematik der Universitaet, D-67653 Kaiserslautern        \  Debian 1:4.2.1-p3+ds-1
// ** but for functionality you may wish to change to the new
// ** format. Please refer to the manual for further information.
The computed myintGCD of 7 is:
1
The computed myintGCD of 38 is:
2

GCD(7,180) = 1
s = -77
t = 3
    
The inverse of 7 modulo 180 is 103

GCD(38,180) = 2
s = 19
t = -4
    
38 has no inverse modulo 180
Auf Wiedersehen.
Execution Time: .008045769 seconds
#+end_example

#+begin_export latex
\[
\subsection{output of hw$1_c$ results}
\begin{lstlisting}[language=Singular]
                     SINGULAR                                 /  Development
 A Computer Algebra System for Polynomial Computations       /   version 4.2.1
                                                           0<
 by: W. Decker, G.-M. Greuel, G. Pfister, H. Schoenemann     \   May 2021
FB Mathematik der Universitaet, D-67653 Kaiserslautern        \  Debian 1:4.2.1-p3+ds-1
// ** but for functionality you may wish to change to the new
// ** format. Please refer to the manual for further information.
The computed myintGCD of 7 is:
1
The computed myintGCD of 38 is:
2

GCD(7,180) = 1
s = -77
t = 3
    
The inverse of 7 modulo 180 is 103

GCD(38,180) = 2
s = 19
t = -4
    
38 has no inverse modulo 180
Auf Wiedersehen.
Execution Time: .022770642 seconds
\end{lstlisting}
\]
#+end_export


Since the gcd for the expression comes out to 1, the inverse exists and is printed out. Since 38 is even, no inverse is possible modulo 180.

* Problem 2
Solving linear diophantine equations using linear congruences.
** a) solving LC $4x \equiv 4\ \text{mod}\ 6$
Solving this is easiest with a table of the results we would get by plugging in any values for x from the set mod 6.

#+begin_export latex
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\( x \) & \( 4x \mod 6 \) & Congruent to 4? \\
\hline
0 & \( 4 \cdot 0 \mod 6 = 0 \) & No \\
1 & \( 4 \cdot 1 \mod 6 = 4 \) & Yes \\
2 & \( 4 \cdot 2 \mod 6 = 2 \) & No \\
3 & \( 4 \cdot 3 \mod 6 = 0 \) & No \\
4 & \( 4 \cdot 4 \mod 6 = 4 \) & Yes \\
5 & \( 4 \cdot 5 \mod 6 = 2 \) & No \\
\hline
\end{tabular}
\end{center}
#+end_export
$\therefore$ we have exactly two solutions which are congruent for this problem.

** Solving as an LDE instead
using the expression $4x \equiv 4\ \text{mod}\ 6$, we can transform the expression into the following:
#+begin_export latex
\begin{align*}
4x &\equiv 4\ \text{mod}\ 6\\
6 &|\ 4x - 4\\
6k &= 4(x - 1)\\
3k &= 2(x - 1)
\end{align*}
Now we find values of $x$ that would allow the expression to be integer valued when $x \in \{0..5\}$. In general, the solutions will be the same as they were before giving us just two possible solutions to the expression. Using the following:
\begin{align*}
 x &= 1\\
 3k &= 2(1 - 1) = 0\\
 k &= 0 \\
 x &= 4\\
 3k &= 2(4 - 1) = 6\\
 k &= 2 
\end{align*}
#+end_export

* Problem 3
We must find a solution to the affine cipher and obtain the keys $[k_1, k_2]$. We can set this up in singular to solve for the key vector using the inverse matrix algorithm that utilizes the transformation to a reduced row eschelon form of the matrix.



#+begin_src bash :results scalar
    start=$(date +%s.%N)
    Singular sing/hw3.sing | grep -v -e \
		"\*\* loaded\|\*\* library\|\*\* redefining"
    end=$(date +%s.%N)
    echo "Execution Time: $(echo "$end - $start" | bc) seconds"
#+end_src

#+RESULTS:
#+begin_example
                     SINGULAR                                 /  Development
 A Computer Algebra System for Polynomial Computations       /   version 4.2.1
                                                           0<
 by: W. Decker, G.-M. Greuel, G. Pfister, H. Schoenemann     \   May 2021
FB Mathematik der Universitaet, D-67653 Kaiserslautern        \  Debian 1:4.2.1-p3+ds-1
print matrix A
18,1,
19,1 
print matrix B
4,
19
Determinant of A:
printing det(A)
25
gcd(det(A), 26) is:
1
inverse of A exists
inverse of A:
inv_A[1,1]=25
inv_A[1,2]=1
inv_A[2,1]=19
inv_A[2,2]=8
check of inv_A*A = I:
_[1,1]=1
_[1,2]=0
_[2,1]=0
_[2,2]=1
Solutions for x = :
_[1,1]=15
_[2,1]=20
Auf Wiedersehen.
Execution Time: .049117479 seconds
#+end_example


#+begin_export latex
\[
\subsection{output of hw$3$ results}
\begin{lstlisting}[language=Singular]
                     SINGULAR                                 /  Development
 A Computer Algebra System for Polynomial Computations       /   version 4.2.1
                                                           0<
 by: W. Decker, G.-M. Greuel, G. Pfister, H. Schoenemann     \   May 2021
FB Mathematik der Universitaet, D-67653 Kaiserslautern        \  Debian 1:4.2.1-p3+ds-1
print matrix A
18,1,
19,1 
print matrix B
4,
19
Determinant of A:
printing det(A)
25
gcd(det(A), 26) is:
1
inverse of A exists
inverse of A:
inv_A[1,1]=25
inv_A[1,2]=1
inv_A[2,1]=19
inv_A[2,2]=8
check of inv_A*A = I:
_[1,1]=1
_[1,2]=0
_[2,1]=0
_[2,2]=1
Solutions for x = :
_[1,1]=15
_[2,1]=20
Auf Wiedersehen.
Execution Time: .053407240 seconds
\end{lstlisting}
\]
#+end_export

Shown above is the results and we see that the key $[k_1, k_2]$ is $[15, 20]$.

* Problem 4 - Hill Cypher
Considering the Hill Cypher, we are restricted to using only 8 letters. Therefore we must do everything modulo 8. Getting the encryption $\mathbf{C} = \mathbf{P}\cdot \mathbf{K}$, and the decryption $\mathbf{P} = \mathbf{C}\cdot \mathbf{K}^{-1}$  will be done as follows:
#+begin_export latex
\[
\mathbf{K} = \left(
\begin{matrix}
k_{11}\ k_{12} \\
k_{21}\ k_{22}
\end{matrix}
\right)
\]
#+end_export




#+begin_export latex
\begin{itemize}
\item[a)] Set up the problem as a system of linear congruences to identify $\mathbf{K}$.\\
\item[b)]Is the given matrix $\mathbf{P}$ invertible? Is the given matrix $\mathbf{C}$ invertible? In other words, can we
We apply the encryption algorithm to the plaintext, character by character:
compute the key as $\mathbf{C} \cdot \mathbf{P}^{−1} = \mathbf{K}$? \\
\item[c)]  Does there exist a unique (one and only one) key matrix $\mathbf{K}$ that satisfies these constraints? If not, how many distinct matrices $\mathbf{K}$ can be used for this cipher?\\
\item[d)]  Based on the above analysis, explain whether the above system is secure to a known-plaintext or a chosen-plaintext attack? [Note: A known-plaintext attack is one where some $(\mathbf{P}, \mathbf{C})$ pairs are known to Eve. A chosen-plaintext attack is similar to the known-plaintext one, except that the $(\mathbf{P}, \mathbf{C})$ pairs are chosen by the attacker herself.] \\
\end{itemize}
#+end_export


