

# This file was *autogenerated* from the file bermas.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2)
from sage.all import *

def berlekamp_massey(s, K):
    """
    Berlekamp-Massey Algorithm to find the minimal polynomial of a sequence in a field K.

    :param s: The sequence (list of elements from K) for which to find the minimal polynomial.
    :param K: The field over which the sequence and polynomials are defined.
    :return: The minimal polynomial for the sequence.
    """
    N = len(s)  # Length of the sequence
    R = PolynomialRing(K, 'x')  # Polynomial ring over the field K
    x = R.gen()  # Generator for the polynomial ring
    C = R.one()  # Connection polynomial, initially 1
    B = R.one()  # Temporary polynomial, initially 1
    L = _sage_const_0   # Current LFSR length
    m = _sage_const_1   # Delay count for the discrepancy
    b = K(_sage_const_1 )  # Last non-zero discrepancy, initially as field element

    # Convert sequence to field elements if not already
    s = [K(coef) for coef in s]

    # Process each term in the sequence
    for n in range(N):
        d = s[n] + sum(C[i] * s[n - i] for i in range(_sage_const_1 , min(L + _sage_const_1 , n + _sage_const_1 )))  # Calculate discrepancy

        if d.is_zero():
            m += _sage_const_1   # Increment m if discrepancy is zero
        elif d.is_one():
            d_inv = d  # Compute inverse of d
            if _sage_const_2  * L <= n:
                T = C  # Temporary copy of C
                C = C - d_inv * (x ** m) * B  # Update C(x)
                L = n + _sage_const_1  - L  # Update L
                B = T  # Update B
                b = d  # Update b
                m = _sage_const_1   # Reset m
            else:
                C = C - d_inv * (x ** m) * B  # Update C(x)
                m += _sage_const_1   # Increment m
        else:
            d_inv = d.inverse()  # Compute inverse of d
            if _sage_const_2  * L <= n:
                T = C  # Temporary copy of C
                C = C - d_inv * (x ** m) * B  # Update C(x)
                L = n + _sage_const_1  - L  # Update L
                B = T  # Update B
                b = d  # Update b
                m = _sage_const_1   # Reset m
            else:
                C = C - d_inv * (x ** m) * B  # Update C(x)
                m += _sage_const_1   # Increment m

    return C, L  # Return the connection polynomial and L

# Example usage in a field GF(2)
K = GF(_sage_const_2 )
sequence = [_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_0 , _sage_const_1 ]
minimal_poly, L = berlekamp_massey(sequence, K)
print("Minimal Polynomial:", minimal_poly)
print("Length of the LFSR:", L)

